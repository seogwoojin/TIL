# 클린 아키텍처

모 선배님과 프로젝트 아키텍처에 관해 토론하며 이해하게 된 내용을 정리하는 글입니다. 즉, 정답이 아닌 그저 제가 느낀 좋은 프로그램 설계란 무엇인가에 대한 글입니다.

~~(글과는 별개로 시립대에는 개발 고수가 여기저기 많은데, 다들 과하게 친절하십니다. 보실지 모르겠지만 감사의 말씀을 남깁니다..)~~

## 결국 모든 프로그램은 도메인을 갖는다.

개발자는 결국 외부 세계를 소프트웨어화하는 프로그램을 만듭니다. 

배달이나, 중고거래, 금융 등등 

현실을 0과 1로 나타내야 하니, 이런 값을 담는 객체가 필요합니다. 

**유저**같은 실제 현실에 존재하는 객체부터, **친구 관계**와 같은 현실에 실재하지 않는 객체도 있습니다.

내가 만약 어떤 서비스를 만들겠다고 하면, 이러한 도메인부터 선정하고 갑니다. 

특정 서비스를 만들 때, 아예 서비스의 방향성이 달라지는 작업이 아니라면 이 도메인은 큰 변화없이 유지됩니다. 

아마 도메인에 변경이 생기는 상황이라면 정부 정책의 변화, 사업 다각화 뭐 이런 굵직 굵직한 일이 아니라면 안바뀝니다.

## 좋은 아키텍처란?

지금 제가 정의하는 좋은 아키텍처는 변화가 적은 부분을 변화 가능성이 높은 부분이 참조하는 행위입니다. 

여기서 참조란 자바 기준 클래스 Import 정도라고 정의할 수 있을 것 같습니다.

![image](https://github.com/user-attachments/assets/62bbc345-6878-4dd4-9681-c95152475a1a)

이는 다르게 말하면 DAG 형태를 소프트웨어가 띄고 있어야 한다는 의미가 됩니다.

정리하면 다음과 같습니다.

1. 변화 가능성이 적은 부분 ( 도메인 ) 은 변화 가능성이 큰 부분을 모른다.
2. 변화 가능성이 큰 부분은 변화 가능성이 적은 부분을 바라본다. 단 사이클이 발생해선 반드시 안된다.

그럼 제가 설정한 이 기준에 맞춰 기존에 작성했던 스프링 프로젝트를 변경하겠습니다. 

## 적용

```
example/
├── api/
│   └── MriController
├── domain/
│   ├── AiResult
│   └── Message
├── external/
│   └── RabbitMQMessageQueue
└── service/
    ├── MessageQueue
    └── MriService
```

저는 비지니스 로직이 담긴 서비스 레이어는 도메인과 묶어 코어 영역인가? 에 대한 의문은 여전히 있습니다. 

OOP적인 측면에서 봤을 때, 도메인을 조회하고, 수정을 요청하고 이러한 일련의 과정이 담긴 비지니스를 객체는 처리할 능력이 없습니다. 

결과적으로 서비스 레이어는 (우선 지금까지는) 도메인 영역에 포함하는 게 맞다고 생각합니다.

```
example/
├── api/
│   └── MriController
├── external/
│   └── RabbitMQMessageQueue (인터페이스 구현체)
├── core/
├──── domain/
      ├── AiResult
      └── Message
└──── service/
      ├── MessageQueue (인터페이스)
      └── MriService

```

결과적으로 이런 폴더 구조가 탄생했습니다. 

Api -> Service는 너무 자주보는 구조일 것이라 생각합니다. 

핵심은 결국, MessageQueue를 어떻게 구현할 것인가?

기존에 저는 service 레이어에서 그대로 RabbitMQMessageQueue 구현체를 주입해서 호출했습니다. 

결국 core 영역이 RabbitMQ 구현체에 종속적인 프로그램이 완성됐습니다. 

이는 자주 바뀔수 있고, 유연해야 할 외부 영역을 core 영역이 전부 알아버리는 문제가 발생합니다. 

한번 만들고 버릴거면 상관없지만 유지보수성이 너무 떨어집니다.

## DI와 인터페이스

이를 위해 등장한 것이 의존성 주입과 인터페이스 입니다. 

MessageQueue 인터페이스를 RabbitMQMessageQueue가 구현합니다. 

결국 이 인터페이스에 맞추지 않으면 RabbitMQMessageQueue는 컴파일 되지 않습니다. 

규격을 core에서 제시하고 외부에서 이에 종속된 개발을 하게끔 유도합니다.

<img width="224" alt="image" src="https://github.com/user-attachments/assets/4ff9eb09-eef1-4c82-8073-a00e75c5c8ef" />

<img width="497" alt="image" src="https://github.com/user-attachments/assets/db25a3bb-9fae-48a1-b890-e4bdcb5b62b2" />

끝으로 스프링의 DI를 통해 자동으로 주입된 구현체를 업캐스팅을 활용해 인터페이스만 Service에서 바라보게 합니다. 

<img width="373" alt="image" src="https://github.com/user-attachments/assets/6a7c9155-12df-4965-8d7d-97891ee383e3" />

이제 우리 MriService는 RabbitMQ의 존재를 아예 모릅니다. (물론 Repository도 이런식으로 변경하는 게 아키텍처적으로는 옳은 것 같습니다.)

그냥 MessageQueue 객체에 sendMesaage 함수를 수행해달라고 요청하는 것 말곤 모릅니다. 

내부적으로 어떻게 구현됐는 지는 별개의 문제이구요.

<br>

## 결과적으로..

이렇게 종속의 흐름을 바꾸어 버린 결과 

![image](https://github.com/user-attachments/assets/75359ac2-f61a-432f-a8ff-aa591b8cab69)

사실상 헥사고날 아키텍처를 재현한 셈이 됐습니다. 

포트나 어답터 이런 말은 그냥 편의를 위해 정해놓은 거지, 방향이나 개념 자체는 제 글과 같다고 생각합니다.

이제 우리 서비스는 MessageQueue의 구현체를 마음껏 변경 가능합니다.

브로커로 카프카를, 레디스를, 아니면 직접 만든 메세지 큐를 사용하는 요구사항의 변경에도 구현체만 바꿔주면 됩니다. 도메인은 늘 하듯이 큐에 sendMessage만 호출하면 그만입니다.

![image](https://github.com/user-attachments/assets/c93fed2c-bd94-47c7-adde-094fcf1ae428)

다행히 실제로 브로커가 정해지지 않은 상태에서 이 방식을 통해 개발을 효율적으로 진행할 수 있었습니다 👍


~~선배님은 여기서 DB도 외부로 뜯어버려야 한다고 했는데, 일단 현재 수준은 JPA를 사용한 개발의 효율성이 유지 보수의 어려움이라는 단점을 뛰어넘는다고 느끼기에 패스하겠습니다~~
