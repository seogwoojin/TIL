# 채팅 서비스 구축하기

## 채팅 시스템의 요구사항 파악하기

페이스북 메신저, 위챗, 인스타 → 1:1 채팅

슬랙 → 그룹 채팅

디스코드 → 대규모 + 낮은 지연시간 기반 음성 채팅

무슨 질문을 통해 요구사항을 파악할 수 있을까?

1. 그룹 or 1:1 or Both
2. DAU의 수준
3. 최대 참가 인원
4. 중요 기능의 종류 (첨부파일, 접속상태 .. )
5. 메세지 길이의 제한 
6. 종단간 암호화 지원 여부
7. 채팅 데이터의 보관 기간

## 채팅 서비스의 기본 기능

- 클라이언트들로부터 메세지 수신
- 메세지 수신자 결정 후 전달
- 수신자가 접속된 상태가 아니라면, 메시지 보관

## 서버가 클라이언트에게 송신하기 위한 프로토콜

(단순 메세지 전송은 문제가 안되며, HTTP도 충분히 가능한 대안)

- 풀링 → 주기적으로 클라이언트가 서버에 요청해 새 메시지 확인, 가장 비효율적
- 롱풀링 → 메세지가 반환되거나, 타임아웃 될 때까지 연결을 유지, 연결이 종료되면 동일 반복, 여전히 비효율적이며, 연결 종료부터 재 요청 사이에 서버는 클라이언트의 접속 여부를 모름
- **웹소켓**
    - **가장 널리 쓰이는 기술**
    - 영구적이며 양방향임
    - 일반적으로 방화벽이 있는 환경에서도 잘 동작함(..?)
    - 유의할 점: 영구적이므로 서버 측에서 연결 관리를 효율적으로 해야함

## 대략적 설계 시작

채팅 시스템의 구성요소 : 무상태 서비스, 상태유지 서비스, 써드파티 서비스(푸시알림 등)

무상태 서비스 : 보통의 서버들 

**상태 유지 서비스** : 클라이언트가 연결 중인 서비스 (서비스 탐색 서버에서 부하를 감지함)

제3자 서비스 : 푸시 알림 서비스 (대부분)

## 규모 확장성 고려

동시 접속자가 1M 일때, 접속당 10KB의 서버 메모리가 필요하다면

이론적으론 10GB 메모리면 처리가 가능하다.

하지만 보통 그 정도 규모의 트래픽을 하나의 서버에 담당시키지 않음 (SPOF 문제 등..)

- 접속 상태 서버는 사용자의 접속 여부를 관리함
- API 서버는 로그인, 회원가입 등 채팅 외의 나머지를 관리함
- 키-값 저장소에는 채팅 이력을 보관한다. 이전 채팅 이력을 보기 위해서

## 저장소

데이터베이스를 채택하자. RDB? NoSQL?

데이터의 유형과 읽기/쓰기 연산의 패턴에 기반해 분석

채팅 시스템 데이터의 유형

1. 사용자 정보, 친구 목록 등의 일반적 데이터
2. 채팅 시스템에 고유한 데이터 = 채팅 이력

2번의 경우. 데이터가 매우 크고, 최근 데이터 위주로 사용되며, 1:1 채팅 기준 읽기:쓰기는 1:1이다.

결과적으로 NoSQL을 추천한다. 이유는 다음과 같다.

1. 수평정 규모 확장이 용이하다
2. 접근 시간이 낮다
3. 많은 채팅 시스템이 이를 차용하고 있다.
4. RDB는 롱 테일에 해당하는 부분을 잘 처리하지 못하는 경향이 있다?

## 채팅 데이터 모델

1:1 채팅을 위한 메시지 테이블

1. 이 테이블의 기본 키(primary key)는 message_id로, 메시지 순서를 쉽게 정할 수 있도록 하는 역할도 담당한다. 두 메시지가 동시에 만들어질 수 있기 때문에 create_at을 사용하여 메시지 순서를 정할 수는 없다.

그룹 채팅을 위한 메시지 테이블

1. channel_id, message_id의 복합 키를 기본 키로 사용한다. channel_id는 파티션 키(partition key)로도 사용할 것인데, 그룹 채팅에 적용될 모든 질의는 특정 채널을 대상으로 할 것이기 떄문이다.

메시지 ID

1. 고유해야 하며 정렬 가능해야 하며 시간 순서와 일치해야 한다. 새로운 ID는 이전 ID보다 큰 값이어야 한다.
2. NoSQL은 auto_increment를 제공하지 않기 때문에 스노플레이크 같은 전역적 64-bit 순서 번호(sequency number) 생성기를 이용한다.
3. 다른 방법은 ID의 유일성은 같은 그룹 안에서만 보증하면 충분하기 떄문에 지역적 순서 번호 생성기 (local sequence number generator)를 사용한다.

## 상세 설계

1. **서비스 탐색**
    - 유저의 위치, 서버의 상태 등에 기반해 적절한 채팅 서버를 제공하는 서버
    - ex) 아파치 주키퍼

1. **1:1 채팅 메시지의 흐름**

1. 사용자 A가 채팅 서버 1로 메시지 전송
2. 채팅 서버 1은 ID 생성기를 사용해 해당 메시지의 ID 결정
3. 채팅 서버 1은 해당 메시지를 메시지 동기화 큐로 전송
4. 메시지가 키-값 저장소에 보관됨
5. 사용자 B가 접속 중인 경우, 메시지는 사용자 B가 접속 중인 채팅 서버인 채팅 서버2로 전송됨
6. 사용자 B가 접속 중이 아니라면 푸시 알림 메시지를 푸시 알림 서버로 보냄
7. 채팅 서버 2는 메시지를 사용자 B에게 전송. 사용자 B와 채팅 서버 2 사이에는 웹 소켓 연결이 되어있어 소켓을 사용함.

1. **여러 단말이 있는 시점**

- 각 단말의 소켓 연결은 독립적임
- 각 단말은 cur_max_message_id 변수를 유지하는데, 해당 단말에서 관측된 가장 최신 메시지의 ID를 추적하는 용도이다.
- 아래 두 조건을 만족하는 메시지는 새 메시지로 간주한다.
    - 수신자 ID가 현재 로그인한 사용자 ID와 같다.
    - 키-값 저장소에 보관된 메시지로서, 그 ID가 cur_max_message_id보다 크다.
- cur_max_message_id는 단말마다 별도로 유지 관리하면 되는 값이라 키-값 저장소에서 새 메시지를 가져오는 동기화 작업도 쉽게 구현할 수 있다

1. **소규모 그룹 채팅의 흐름**

(대략 500명 이하의 그룹 채팅 기준)

그룹 채팅방에 메시지를 보내면, 이 메시지가 그룹 유저별 메시지 큐에 복사된다.

본인 큐만 확인하면 되므로 동기화가 간편해진다

1. **접속 상태 표시**

일반적으로 접속 상태 서버를 통해 상태를 관리한다.

사용자와 서버간의 웹소켓 연결이 맺어지고 나면, 보관하는 정보 : 유저의 상태, 최신 접속 시간

로그아웃 이후 → 상태를 변경 

접속 장애 대처 → 잠깐 소켓 연결이 끊기는 경우에 상태변화를 매번 해줘야 하는가

하트비트 → 주기적으로 박동 이벤트를 보냄으로 접속을 증명

특정 시간(ex. 30초) 박동이 없으면 서버는 연결이 끊어진 것으로 판단 → 상태 변화 

이 상태 변화를 어떻게 친구들에게 전달할지

실시간 변화가 요구 사항이라면 다음과 같은 발행-구독 모델을 사용한다.

그룹이 크면 (10만명) 상태 변화 1건당 10만개의 이벤트 메시지 발행해야 함

이 경우, 사용자가 입장할 때 한번만 상태를 읽고 수동으로 접속 상태를 갱신하도록 ‘유도’함

## 더 생각해 볼 점

- 채팅 메시지에 영상, 사진의 경우 어떻게 압축하고 썸네일 생성할지 (카카오톡)
- 종단 간 암호화
- 여러 명이 연결된 채팅 서버가 죽는다면, 새로운 서버 배정
